@using FateExplorer.RollLogic

@inject IStringLocalizer<App> l10n


<MudCard Elevation=2 Class="pa-1 ma-1">
    <MudCardHeader>
        <CardHeaderAvatar>
            <MudAvatar Color=@GetAvatarColor(Result.SuccessLevel) Square=true Size=Size.Large>
                <MudIcon Color=Color.Dark Icon=@GetAvatarIcon(Result.SuccessLevel) Size=Size.Large />
            </MudAvatar>
        </CardHeaderAvatar>
        <CardHeaderContent>
            <MudText Typo="Typo.body1">@l10n["roll"+Result.SuccessLevel.ToString()]</MudText>
            <MudText Typo="Typo.caption">@Result.Name</MudText>
        </CardHeaderContent>
        <CardHeaderActions>
            @if (CanClose)
            {
                <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Default" />
            }
        </CardHeaderActions>
    </MudCardHeader>

    <MudCardContent>
        <MudGrid Spacing=0 Class="my-1">
            <MudItem xs=12>
                <MudSimpleTable Dense=true Hover=false Bordered=false Striped=false Elevation=0 Class="rolltable">
                @* Style="overflow-x: auto;" *@
                <tbody>
                    <tr>
                        <td>@*AttributeLabel*@</td>
                        @if (ShowValueLabel is null)
                            @AttrHead(Result.RollAttrName)
                        else
                        {
                            <td><MudText Typo=Typo.caption>
                                @ShowValueLabel
                            </MudText></td>
                        }
                        @if (Result.TargetAttr is not null) 
                            @TargetAttrHead(Result.TargetAttrName)
                        <td><MudText Typo=Typo.caption>@l10n["lblResultCardModifier"]</MudText></td>
                    </tr>
                    <tr>
                        <td>@l10n["lblAttributeValue"]</td>
                        @AttrValue(PrimRollResult.RollAgainst)
                        @if (Result.TargetAttr is not null)
                            @TargetAttrValues(Result.TargetAttr)
                        <td>@Result.SummarizedModifier</td>
                    </tr>
                    <tr>
                        <td>@l10n["lblRoll"]</td>
                        @AttrValue(PrimRollResult.RollResult)
                        @if (Result.TargetAttr is not null)
                            @TargetAttrValues(Result.Remainder)
                        <td> &nbsp; </td>  @*No roll against the mod*@
                    </tr>
                </tbody>
            </MudSimpleTable>
            @if (Result.Classification is not null)
            {
            <p class="py-4">
                @l10n[Result.ClassificationLabel] @Result.Classification
            </p>
            }
            </MudItem>
        </MudGrid>
    </MudCardContent>
    @if (Result.PrimaryNeedsConfirmation())
    {
    <MudCardContent>
        <MudText Typo=Typo.body1 Class="d-inline pr-2">
            @l10n["roll"+Result.SuccessLevel.ToString()]
        </MudText>
        <MudButton OnClick=@(() => RollConfirm()) Color=@GetAvatarColor(Result.SuccessLevel) Variant=Variant.Filled Class="d-inline">
            @l10n["btnConfirm"]
        </MudButton>
    </MudCardContent>
    }
    @if (Result.GetConfirmationResult() is not null)
    {
    <MudCardContent>
        <MudText Typo=Typo.body1 Class="d-inline">@GetConfirmationMessage(Result.SuccessLevel)</MudText>
        <MudText Typo=Typo.body1 Class="d-inline">
            [@l10n["lblRoll"] @(Result.GetRollResult(RollType.Confirm).CombinedResult)]
        </MudText>
    </MudCardContent>
    }
    @if (Result.NeedsBotchEffect())
    {
    <MudCardContent>
        <MudButton Color=@GetAvatarColor(Result.SuccessLevel)>
            @l10n["btnBotchEffect"]
        </MudButton>
    </MudCardContent>
    }
</MudCard>


@code {
    /// <summary>
    /// A result object carrying the required data to display the card
    /// </summary>
    [Parameter]
    public RollCheckResultViMo Result { get; set; }

    /// <summary>
    /// Displays an extra x-Icon users can close the card with.
    /// </summary>
    [Parameter]
    public bool CanClose { get; set; } = false;

    /// <summary>
    /// Display an extra row with value labels
    /// </summary>
    [Parameter]
    public string ShowValueLabel { get; set; }


    /// <summary>
    /// A list of strings holding the icons that can be used as avatars. 
    /// Supports 1, 2, 4 or 6 different icons to be displayed with different success
    /// levels.
    /// </summary>
    [Parameter]
    public string[] AvatarIcon { get; set; } = { Icons.Material.Filled.HelpCenter };



    protected RollResultViMo PrimRollResult { get; set; }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        PrimRollResult = Result.GetPrimaryResult();
    }


    private void RollConfirm()
    {
        Result.GetRollResult(RollType.Confirm, true);
        this.StateHasChanged();
    }



    // TEMPLATES

    private string GetAvatarIcon(RollSuccessLevel Success)
    {
        if (AvatarIcon.Length == 1)
            return AvatarIcon[0];
        if (AvatarIcon.Length == 2)
        {
            return Success switch
            {
                RollSuccessLevel.Botch => AvatarIcon[0],
                RollSuccessLevel.PendingBotch => AvatarIcon[0],
                RollSuccessLevel.Fail => AvatarIcon[0],
                RollSuccessLevel.Critical => AvatarIcon[1],
                RollSuccessLevel.Success => AvatarIcon[1],
                RollSuccessLevel.PendingCritical => AvatarIcon[1],
                _ => Icons.Material.Filled.HelpCenter
            };
        }        
        if (AvatarIcon.Length == 4)
        {
            return Success switch
            {
                RollSuccessLevel.Botch => AvatarIcon[0],
                RollSuccessLevel.PendingBotch => AvatarIcon[0],
                RollSuccessLevel.Fail => AvatarIcon[1],
                RollSuccessLevel.Success => AvatarIcon[2],
                RollSuccessLevel.PendingCritical => AvatarIcon[3],
                RollSuccessLevel.Critical => AvatarIcon[3],
                _ => Icons.Material.Filled.HelpCenter
            };
        }
        if (AvatarIcon.Length == 6)
        {
            return Success switch
            {
                RollSuccessLevel.Botch => AvatarIcon[0],
                RollSuccessLevel.PendingBotch => AvatarIcon[1],
                RollSuccessLevel.Fail => AvatarIcon[2],
                RollSuccessLevel.Success => AvatarIcon[3],
                RollSuccessLevel.PendingCritical => AvatarIcon[4],
                RollSuccessLevel.Critical => AvatarIcon[5],
                _ => Icons.Material.Filled.HelpCenter
            };
        }
        return Icons.Material.Filled.HelpCenter;
    }



    private Color GetAvatarColor(RollSuccessLevel Success) =>
        Success switch
        {
            RollSuccessLevel.Botch => Color.Error,
            RollSuccessLevel.Fail => Color.Error,
            RollSuccessLevel.Critical => Color.Success,
            RollSuccessLevel.Success => Color.Success,
            RollSuccessLevel.PendingBotch => Color.Warning,
            RollSuccessLevel.PendingCritical => Color.Warning,
            _ => Color.Info
        };


    private string GetConfirmationMessage(RollSuccessLevel Outcome) =>
        Outcome switch
        {
            RollSuccessLevel.Botch => l10n["msgBotchConfirmed"],
            RollSuccessLevel.Fail => l10n["msgBotchAvoided"],
            RollSuccessLevel.Success => l10n["msgCriticalLost"],
            RollSuccessLevel.Critical => l10n["msgCriticalConfirmed"],
            _ => ""
        };



    RenderFragment<string> TargetAttrHead = Name => __builder =>
    {
        if (Name is not null)
        {
            <td><MudText Typo=Typo.caption>@Name</MudText></td>
        }
    };

    RenderFragment<int?> TargetAttrValues = Value => __builder =>
    {
        if (Value is not null)
        {
        <td>@Value</td>
        }
    };


    RenderFragment<string[]> AttrHead = Name => __builder =>
    {
        if (Name is not null)
        {
            foreach (var n in Name)
            {
            <td><MudText Typo=Typo.caption>@n</MudText></td>
            }
        }
    };

    RenderFragment<int[]> AttrValue = Value => __builder =>
    {
        if (Value is not null)
        {
            foreach (var v in Value)
            {
            <td>@v</td>
            }
        }
    };

}
