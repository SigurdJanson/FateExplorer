<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Memory" #> 
<#@ assembly name="System.Text.Json" #>
<#@ import namespace="System.Text.Json" #>
<#@ import namespace="System.Text.Json.Serialization" #>
<#@ assembly name="$(ProjectDir)$(OutDir)System.Runtime.dll" #>
<# #>
<# #>
//
// IMPORTANT: DO NOT EDIT THIS FILE. IT IS GENERATED BY THE TEMPLATE <#= Path.GetFileName(this.Host.TemplateFile)#>.
//
namespace FateExplorer.Shared;

/// <summary>
/// Gives access to the string identifiers of characters' advantages
/// </summary>
public static class SA
{
<#  
    const string Path2wwwrootData = "D:\\Programmierung\\FateExplorer\\dev\\wwwroot\\data"; //"..\\..\\..\\..\\dev\\wwwroot\\data";
    string BasePath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, Path2wwwrootData));
    string fileName = Path.GetFullPath(Path.Combine(BasePath, "specabs_en.json"));
    string jsonString = File.ReadAllText(fileName);
    SpecialAbilityDB DataBase = JsonSerializer.Deserialize<SpecialAbilityDB>(jsonString);
    IReadOnlyList<SpecialAbilityDbEntry> Content = DataBase.Data;

    PushIndent("    ");
    foreach (var item in Content) { 
		if (!string.IsNullOrEmpty(item.Id))
			WriteLine($"public const string {IdentifierMaker.ConvertToIdentifier(item.Name)} = \"{ item.Id}\";");
    }
	ClearIndent();
#>
}
<# #>
<# #>
<# #>
<# #>
<#+
// Careful! This code had to be duplicated. Waiting for a solution to use my own code.

public class SpecialAbilityDbEntry
{
    [JsonPropertyName("id")]
    public string Id { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }
}
public class SpecialAbilityDB
{
    [JsonPropertyName("Entries")]
    public List<SpecialAbilityDbEntry> Data { get; set; }
}


/// <summary>
/// Converts an arbitrary string into an identifier
/// </summary>
public static class IdentifierMaker
{
    public static IReadOnlyDictionary<string, string> SPECIAL_DIACRITICS = new Dictionary<string, string>
    {
        { "ä".Normalize(NormalizationForm.FormD), "ae".Normalize(NormalizationForm.FormD) },
        { "Ä".Normalize(NormalizationForm.FormD), "Ae".Normalize(NormalizationForm.FormD) },
        { "ö".Normalize(NormalizationForm.FormD), "oe".Normalize(NormalizationForm.FormD) },
        { "Ö".Normalize(NormalizationForm.FormD), "Oe".Normalize(NormalizationForm.FormD) },
        { "ü".Normalize(NormalizationForm.FormD), "ue".Normalize(NormalizationForm.FormD) },
        { "Ü".Normalize(NormalizationForm.FormD), "Ue".Normalize(NormalizationForm.FormD) },
        { "ß".Normalize(NormalizationForm.FormD), "ss".Normalize(NormalizationForm.FormD) },
    };

    public static string ReplaceDiacritics(string s)
    {
        var stringBuilder = new StringBuilder(s.Normalize(NormalizationForm.FormD));

        // Replace certain special chars with special combinations of ascii chars (eg. german umlauts and german double s)
        foreach (KeyValuePair<string, string> keyValuePair in SPECIAL_DIACRITICS)
            stringBuilder.Replace(keyValuePair.Key, keyValuePair.Value);

        // Remove other diacritic chars eg. non spacing marks https://www.compart.com/en/unicode/category/Mn
        for (int i = 0; i < stringBuilder.Length; i++)
        {
            char c = stringBuilder[i];

            if (CharUnicodeInfo.GetUnicodeCategory(c) == UnicodeCategory.NonSpacingMark)
                stringBuilder.Remove(i, 1);
        }

        return stringBuilder.ToString();
    }


    public static string RemoveTierIndicator(string s)
    {
        string replacement = "";
        string pattern = @"(?'id'[IVX\- ]+)\s*$";

        string name = null;

        var result = Regex.Replace(s, pattern, m =>
        {
            name = m.Groups["id"].Value;
            return replacement;
        }, RegexOptions.IgnorePatternWhitespace);
        return result;
    }




    public static String ConvertToIdentifier(String s)
    {
        s = ReplaceDiacritics(s);
        s = RemoveTierIndicator(s);

        String normalizedString = s.Normalize(NormalizationForm.FormD);
        StringBuilder stringBuilder = new StringBuilder();

        bool WordGap = true;
        for (int i = 0; i < normalizedString.Length; i++)
        {
            Char c = normalizedString[i];
            if (WordGap)
            {
                WordGap = false;
                c = Char.ToUpper(c);
            }

            switch (CharUnicodeInfo.GetUnicodeCategory(c))
            {
                // Always allowed
                case UnicodeCategory.LowercaseLetter:
                case UnicodeCategory.UppercaseLetter:
                    //case UnicodeCategory.LowercaseLetter: 
                    stringBuilder.Append(c); break;
                // Not as 1st character
                case UnicodeCategory.DecimalDigitNumber:
                    if (i != 0) stringBuilder.Append(c); //else Error("Name starts with digit");
                    break;
                case UnicodeCategory.SpaceSeparator:
                    WordGap = true; break;
            }
        }

        return stringBuilder.ToString();
    }

}
#>